% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ssvQC.R, R/ssvQC_FRIP.R, R/ssvQC_SCC.R,
%   R/ssvQC_capValue.R, R/ssvQC_correlation.R, R/ssvQC_features.R,
%   R/ssvQC_fragLens.R, R/ssvQC_mappedReads.R, R/ssvQC_signal.R
\name{show,ssvQC-method}
\alias{show,ssvQC-method}
\alias{ssvQC}
\alias{ssvQC.runAll}
\alias{ssvQC.prepFetch}
\alias{ssvQC.referenceUsesSameScale}
\alias{ssvQC.prepFRIP}
\alias{ssvQC.plotFRIP}
\alias{ssvQC.prepSCC}
\alias{ssvQC.plotSCC}
\alias{ssvQC.prepCapValue}
\alias{ssvQC.prepCorrelation}
\alias{ssvQC.plotCorrelation}
\alias{ssvQC.prepFeatures}
\alias{ssvQC.plotFeatures}
\alias{ssvQC.prepFragLens}
\alias{ssvQC.prepMappedReads}
\alias{ssvQC.plotMappedReads}
\alias{ssvQC.prepSignal}
\alias{ssvQC.plotSignal}
\title{ssvQC}
\usage{
\S4method{show}{ssvQC}(object)

ssvQC(
  features_config = NULL,
  signal_config = NULL,
  out_dir = getwd(),
  bfc = NULL,
  matched_only = TRUE
)

ssvQC.runAll(object)

ssvQC.prepFetch(object)

ssvQC.referenceUsesSameScale(object)

ssvQC.prepFRIP(object)

ssvQC.plotFRIP(object)

ssvQC.prepSCC(object)

ssvQC.plotSCC(object)

ssvQC.prepCapValue(object, query, bfc, use_matched)

ssvQC.prepCorrelation(object)

ssvQC.plotCorrelation(object)

ssvQC.prepFeatures(object, bfc)

ssvQC.plotFeatures(object, force_euler)

ssvQC.prepFragLens(object, query, bfc, use_matched)

ssvQC.prepMappedReads(object)

ssvQC.plotMappedReads(object)

ssvQC.prepSignal(object)

ssvQC.plotSignal(object)
}
\arguments{
\item{features_config}{Controls features configuration.  May be a:
QcConfigFeatures object, path to a file defining configuration via
QcConfigFeatures.parse, features files to define via
QcConfigFeatures.files, or a data.frame to pass to QcConfigFeatures.}

\item{signal_config}{Controls signal configuration.  May be a: QcConfigSignal
object, path to a file defining configuration via QcConfigSignal.parse,
features files to define via QcConfigSignal.files, or a data.frame to pass
to QcConfigSignal.}

\item{out_dir}{NYI}

\item{bfc}{BiocFileCache object to use for caching. If NULL, default
new_cache() will be used.}

\item{force_euler}{If TRUE forces Euler plots to be generated for a list of feature sets longer than 8.  Euler plots can take quite a long time to generate as more feature sets are generated.}

\item{ssvQC}{}
}
\value{
A ssvQC object.  Data needs to be loaded after via ssvQC.runAll or sub-methods ssvQC.plot*.
}
\description{
ssvQC

ssvQC
}
\examples{
options(mc.cores = 1)
set.seed(0)
# To make an ssvQC object, confiugration for features (peaks, other genomic 
regions) and signal (numeric values on the genome from bam pileups or bigwigs)
features_config_file = system.file(
  package = "ssvQC", 
  "extdata/ssvQC_peak_config.csv"
)
features_config = QcConfigFeatures.parse(features_config_file)

bam_config_file = system.file(
  package = "ssvQC", 
  "extdata/ssvQC_bam_config.csv"
)
bam_config = QcConfigSignal.parse(bam_config_file)

bigwig_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bigwig_config.csv")
bigwig_config = QcConfigSignal.parse(bigwig_config_file)

# Different ways to make ssvQC objects
sqc.complete.file = ssvQC(features_config_file, bam_config_file)

sqc.complete = ssvQC(features_config, bam_config)

sqc.complete.bw = ssvQC(features_config, bigwig_config_file)

sqc.signal = ssvQC(signal_config = bam_config)

sqc.feature = ssvQC(features_config = features_config)

# ssvQC.runAll will run all appropriate QC methods
sqc.signal = ssvQC.runAll(sqc.signal)

sqc.feature = ssvQC.runAll(sqc.feature)

sqc.complete = ssvQC.runAll(sqc.complete)

sqc.complete$plots$signal$heatmaps
sqc.complete$signal_config@plot_value = "RPM"
sqc.complete = ssvQC.plotSignal(sqc.complete)
sqc.complete$plots$signal$heatmaps

sqc.complete$signal_config@plot_value = "linearQuantile"
sqc.complete = ssvQC.plotSignal(sqc.complete)
sqc.complete$plots$signal$heatmaps

sqc.complete$signal_config@plot_value = SQC_SIGNAL_VALUES$RPM_linearQuantile
sqc.complete = ssvQC.plotSignal(sqc.complete)
sqc.complete$plots$signal$heatmaps

write_ssvQC.summary(sqc.complete)
write_ssvQC.per_peak(sqc.complete)
write_ssvQC.correlation(sqc.complete)

}
