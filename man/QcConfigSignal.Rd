% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/QcConfigSignal.R
\docType{class}
\name{QcConfigSignal-class}
\alias{QcConfigSignal-class}
\alias{QcConfigSignal}
\alias{QcConfigSignal.null}
\alias{QcConfigSignal.parse}
\alias{QcConfigSignal.files}
\alias{fetch_signal_at_features}
\alias{QcConfigSignal.save_config}
\title{QcConfigSignal}
\usage{
QcConfigSignal(
  config_df,
  run_by = "All",
  to_run = NULL,
  to_run_reference = NULL,
  color_by = "file",
  color_mapping = NULL,
  read_mode = NULL,
  view_size = getOption("SQC_VIEW_SIZE", 3000),
  window_size = 200,
  fetch_options = list(),
  cluster_value = NULL,
  linearQuantile_cutoff = 0.98,
  sort_value = NULL,
  sort_method = c("hclust", "sort")[2],
  plot_value = NULL,
  heatmap_limit_values = c(0, 10),
  lineplot_free_limits = TRUE,
  center_signal_at_max = FALSE,
  flip_signal_mode = flip_signal_modes$none,
  is_null = FALSE,
  n_clusters = 6
)

QcConfigSignal.null()

QcConfigSignal.parse(signal_config_file)

QcConfigSignal.files(
  file_paths,
  file_paths.input = character(),
  run_separately = TRUE,
  sample_names = NULL,
  sample_names.split = NULL,
  group_names = NULL,
  group_name.input = "input",
  group_colors = NULL,
  view_size = getOption("SQC_VIEW_SIZE", 3000),
  window_size = getOption("SQC_WINDOW_SIZE", 200),
  read_mode = NULL,
  cluster_value = NULL,
  linearQuantile_cutoff = 0.98,
  sort_value = NULL,
  plot_value = NULL,
  sort_method = c("hclust", "sort")[2],
  center_signal_at_max = FALSE,
  flip_signal_mode = flip_signal_modes$none,
  n_clusters = 6
)

fetch_signal_at_features(qc_signal, query_gr, bfc = new_cache())

QcConfigSignal.save_config(object, file)
}
\arguments{
\item{config_df}{A data.frame containing configuration information for signal
(bam or bigwig) files. Should contain a "file" attribute and entires for
run_by and color_by.}

\item{run_by}{Name of the attribute specify how signal data should be
grouped.}

\item{to_run}{Values in run_by that represent running groups.}

\item{to_run_reference}{Values in run_by that should be included in all run
groups.}

\item{color_by}{Name of the attribute specify how signal data should be
colored in relevant plots}

\item{color_mapping}{Name character vector where names are values of color_by
and values are valid R colors (color names or hex values).}

\item{read_mode}{Read mode of signal data, one of bam_SE, bam_PE, or bigwig.
Use SQC_READ_MODES$.}

\item{view_size}{view size in bp to apply. Defaults to 3000.}

\item{window_size}{The window size used when fetching signal. Lower values
increase resolution but also RAM usage. Default is 200 bp.}

\item{fetch_options}{Named list of additional arguments to pass to signal
fetch function.}

\item{cluster_value}{Value in SQC_SIGNAL_VALUES$ to use for clustering. RPM
values are not valid if read_mode is "bigwig".}

\item{linearQuantile_cutoff}{Quantile to use for linearQuantile normalization
procedure. Values above this cutoff are treated as outliers.}

\item{sort_value}{Value in SQC_SIGNAL_VALUES$ to use for sorting. RPM values
are not valid if read_mode is "bigwig".}

\item{sort_method}{One of two available method to use when sorting within
clusters. If "hclust", hierarchical clustering is applied. If the default
of "sort", regions are sorting by decreasing signal.}

\item{plot_value}{Value in SQC_SIGNAL_VALUES$ to represent in plots. RPM
values are not valid if read_mode is "bigwig".}

\item{heatmap_limit_values}{Color scale limits for heatmaps. Default is 0 to
10.}

\item{lineplot_free_limits}{If TRUE (default), lineplot facets per cluster
will have free axis. If FALSE a consistnet y-axis is used for all clusters.}

\item{center_signal_at_max}{If TRUE, signal is centered at local maxima prior
to any clustering. The default is FALSE. See details for explanation or
interaction with assessment features.}

\item{flip_signal_mode}{Value is SQC_FLIP_SIGNAL_MODES$.  If not "none"
(Default) signal profiles are flipped so that highest signal is on one side
or the other.  See details for explanation or interaction with assessment
features.}

\item{is_null}{If TRUE, this QcConfigSignal is considered null/empty.}

\item{n_clusters}{The number of k-means clusters for the heatmap.

  Since center_signal_at_max and flip_signal_mode have the potential to
  modify the assessment regions based on signal run groups, the modified
  assessment feature set is store in signal_data for each run group. They can
  be accessed like this: sqc$signal_data$FEATURE_NAME$SIGNAL_NAME$query_gr}

\item{signal_config_file}{Configuration file for signal data.}

\item{file_paths}{character paths to files}

\item{group_names}{vector of group names to assign from according to groups}

\item{group_colors}{vector of colors to use per group}

\item{qc_signal}{A QcConfigSignal object}

\item{query_gr}{A GRanges to fetch data for}

\item{groups}{numeric vector of group assignments. 1 is first item in group_names, 2 is second, etc. Default is seq_along(file_path)}
}
\value{
A QcConfigSignal object

A null/empty QcConfigSignal object

A QcConfigSignal object

a QcConfigSignal object

A list of 2 items prof_dt and query_gr.  prof_dt is a tidy data.table
  of signal profiles.  query_gr is a GRanges that may have been modified from
  input query_gr if signal profiles are flipped or centered according to
  center_signal_at_max or flip_signal_mode in the signal config.

Invisibly returns path to saved config file.
}
\description{
QcConfigSignal

QcConfigSignal

QcConfigSignal null placeholder

QcConfigSignal.files

QcConfigSignal.save_config
}
\section{Slots}{

\describe{
\item{\code{view_size}}{}

\item{\code{read_mode}}{}

\item{\code{fetch_options}}{}

\item{\code{cluster_value}}{}

\item{\code{linearQuantile_cutoff}}{}

\item{\code{sort_value}}{}

\item{\code{sort_method}}{}

\item{\code{plot_value}}{}

\item{\code{heatmap_limit_values}}{}

\item{\code{lineplot_free_limits}}{}

\item{\code{center_signal_at_max}}{}

\item{\code{flip_signal_mode}}{}

\item{\code{n_clusters}}{}
}}

\examples{
bam_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bam_config.csv")
bam_config_df = .parse_config_body(bam_config_file)
sig_conf = QcConfigSignal(bam_config_df)

bigwig_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bigwig_config.csv")
bigwig_config_df = .parse_config_body(bigwig_config_file)
sig_conf.bw = QcConfigSignal(bigwig_config_df)
QcConfigSignal.null()
bam_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bam_config.csv")
QcConfigSignal.parse(bam_config_file)

bigwig_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bigwig_config.csv")
QcConfigSignal.parse(bigwig_config_file)
bam_files = dir(system.file(package = "ssvQC", "extdata"), pattern = "CTCF.+bam$", full.names = TRUE)
object = QcConfigSignal.files(bam_files)
plot(object)

object2 = QcConfigSignal.files(bam_files,
  sample_names = c("MCF10A_CTCF", "MCF10AT1_CTCF", "MCF10CA1a_CTCF"), 
  group_names = c("10A", "AT1", "CA1"),
  group_colors = c("firebrick", "slategray2", "forestgreen")
)
plot(object2)
bam_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bam_config.csv")
qc_signal = QcConfigSignal.parse(bam_config_file)

feature_config_file = system.file(package = "ssvQC", "extdata/ssvQC_peak_config.csv")
qc_features = QcConfigFeatures.parse(feature_config_file)
query_gr = qc_features$assessment_features
fetch_signal_at_features(qc_signal, query_gr)
bam_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bam_config.csv")
bam_config = QcConfigSignal.parse(bam_config_file)
#QcConfigSignal.save_config(bam_config, "bam_config.csv")

bigwig_config_file = system.file(package = "ssvQC", "extdata/ssvQC_bigwig_config.csv")
bigwig_config = QcConfigSignal.parse(bigwig_config_file)
#QcConfigSignal.save_config(bigwig_config, "bigwig_config.csv")
}
